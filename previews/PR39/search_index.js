var documenterSearchIndex = {"docs":
[{"location":"functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions.html","page":"Functions","title":"Functions","text":"CurrentModule = MaterialModels","category":"page"},{"location":"functions.html","page":"Functions","title":"Functions","text":"initial_material_state\nget_cache\nupdate_cache!","category":"page"},{"location":"functions.html#MaterialModels.initial_material_state","page":"Functions","title":"MaterialModels.initial_material_state","text":"initial_material_state(::AbstractMaterial)\n\nReturn the MaterialState that belongs to the given Material and is initialized with zeros. \n\n\n\n\n\n","category":"function"},{"location":"functions.html#MaterialModels.get_cache","page":"Functions","title":"MaterialModels.get_cache","text":"get_cache(m::AbstractMaterial)\n\nConstruct cache object for iteratively solving non-linear material models.\n\nFor material models which require an iterative solution procedure, it is recommended to allocate storage for the iterative solver only once and reuse it for all material points. When multithreading is used, each threads needs its own cache.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#MaterialModels.update_cache!","page":"Functions","title":"MaterialModels.update_cache!","text":"update_cache!(cache::OnceDifferentiable, f)\n\nUpdate the cache object with the residual function for the current time/load step.\n\nAs the residual functions depend i.a. on the strain increment, the function and its jacobian need to be updated for every load step.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#Material-model-interface","page":"Interface","title":"Material model interface","text":"","category":"section"},{"location":"interface.html","page":"Interface","title":"Interface","text":"For fullfilling the AbstractMaterial interface, the following functions need to be defined:","category":"page"},{"location":"interface.html","page":"Interface","title":"Interface","text":"CurrentModule = MaterialModels","category":"page"},{"location":"interface.html","page":"Interface","title":"Interface","text":"AbstractMaterial\nAbstractMaterialState\nmaterial_response","category":"page"},{"location":"interface.html#MaterialModels.AbstractMaterial","page":"Interface","title":"MaterialModels.AbstractMaterial","text":"AbstractMaterial\n\nStore material parameters here. It can also be used to store constant precomputed properties, e.g. the elastic stiffness tensor. Ideally, the name should be chosen according to the first author of the initial publication of a model. For every Material there should be a keyword constructor and a list of arguments in the docstrings. If possible, also include the reference to a publication.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#MaterialModels.AbstractMaterialState","page":"Interface","title":"MaterialModels.AbstractMaterialState","text":"AbstractMaterialState\n\nStore state variables here. For now, this should not be mutable, a new object should be constructed for every new state. (We can discuss if this is a good or a bad idea.)\n\n\n\n\n\n","category":"type"},{"location":"interface.html#MaterialModels.material_response","page":"Interface","title":"MaterialModels.material_response","text":"material_response(m::AbstractMaterial, Δε::SymmetricTensor{2,3}, state::AbstractMaterialState, Δt; cache, options)\n\nCompute the stress, stress tangent and state variables for the given strain increment Δε and previous state state.\n\nInstead of the strain increment, the total strain could be handed over. Good ideas on how to handle this in general are welcome. For non-continuum kind of material models, the interface should be similar with stress-like and strain-like quantities. (E.g. for cohesive laws traction instead of stress and displacement jump instead of strain.) This function signature must be the same for all material models, even if they don't require all arguments.\n\n\n\n\n\n","category":"function"},{"location":"materials/LinearElastic.html#LinearElastic","page":"LinearElastic","title":"LinearElastic","text":"","category":"section"},{"location":"materials/LinearElastic.html","page":"LinearElastic","title":"LinearElastic","text":"LinearElastic\nmaterial_response(m::LinearElastic, Δε::SymmetricTensor{2,3}, state::LinearElasticState)","category":"page"},{"location":"materials/LinearElastic.html#MaterialModels.LinearElastic","page":"LinearElastic","title":"MaterialModels.LinearElastic","text":"LinearElastic(E, ν)\n\nIsotropic linear elasticity.\n\nArguments\n\nE::Float64: Young's modulus\nν::Float64: Poisson's ratio\n\n\n\n\n\n","category":"type"},{"location":"materials/LinearElastic.html#MaterialModels.material_response-Tuple{LinearElastic,SymmetricTensor{2,3,T,M} where M where T,LinearElasticState}","page":"LinearElastic","title":"MaterialModels.material_response","text":"material_response(m::LinearElastic, ε::SymmetricTensor{2,3})\n\nReturn the stress tensor and the stress tangent for the given strain ε such that\n\nboldsymbolsigma = mathbfE^texte  boldsymbolvarepsilon \n\nNo MaterialState is needed for the stress computation, thus if a state is handed over to material_response, the same state is returned.\n\n\n\n\n\n","category":"method"},{"location":"materials/XuNeedleman.html#XuNeedleman","page":"XuNeedleman","title":"XuNeedleman","text":"","category":"section"},{"location":"materials/XuNeedleman.html","page":"XuNeedleman","title":"XuNeedleman","text":"Modules = [MaterialModels]\nPages = [\"XuNeedleman.jl\"]","category":"page"},{"location":"materials/XuNeedleman.html#MaterialModels.XuNeedleman","page":"XuNeedleman","title":"MaterialModels.XuNeedleman","text":"XuNeedleman(σₘₐₓ, τₘₐₓ, δₙ, δₜ, Φₙ, Φₜ, Δₙˢ)\n\nXu-Needleman traction-separation law.[Xu1993] This is a commonly used cohesive law for brittle fracture,  however it is revertible and thus not suited for unloading. In 3D, it is isotropic within the cohesive plane.\n\n[Xu1993]: Xu, X. P., & Needleman, A. (1993). Void nucleation by inclusion debonding in a crystal matrix. Modelling and Simulation in Materials Science and Engineering, 1(2), 111–132. https://doi.org/10.1088/0965-0393/1/2/001\n\nArguments\n\nσₘₐₓ::Float64: cohesive normal strength\nτₘₐₓ::Float64: cohesive tangential strength (in-plane strength)\nδₙ::Float64: characteristic normal separation\nδₜ::Float64`: characteristic tangential separation\nΦₙ::Float64: normal work of separation\nΦₜ::Float64: tangential work of separation\nΔₙˢ: normal separation after complete shear separation under the condition of zero normal tension\n\nOut of the pairs cohesive strength / characteristic normal separation / work of separation any two can be given for construction the XuNeedleman material.\n\n\n\n\n\n","category":"type"},{"location":"materials/XuNeedleman.html#MaterialModels.material_response-Union{Tuple{dim}, Tuple{XuNeedleman,Tensor{1,dim,T,M} where M where T}, Tuple{XuNeedleman,Tensor{1,dim,T,M} where M where T,XuNeedlemanState}, Tuple{XuNeedleman,Tensor{1,dim,T,M} where M where T,XuNeedlemanState,Any}, Tuple{XuNeedleman,Tensor{1,dim,T,M} where M where T,XuNeedlemanState,Any,Any}, Tuple{XuNeedleman,Tensor{1,dim,T,M} where M where T,XuNeedlemanState,Any,Any,Any}} where dim","page":"XuNeedleman","title":"MaterialModels.material_response","text":"material_response(m::XuNeedleman, Δ::Tensor{1,dim}) where dim\n\nReturn the traction vector and the traction tangent for the given separation jump Δ. The last entry of Δ is interpreted as normal separation, the first entries are interpreted as in-plane separations.\n\nNo MaterialState is needed for the stress computation, thus if a state is handed over to material_response, the same state is returned.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Materials","page":"Home","title":"Materials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to MaterialModels.jl","category":"page"},{"location":"materials/Plastic.html#Plastic","page":"Plastic","title":"Plastic","text":"","category":"section"},{"location":"materials/Plastic.html","page":"Plastic","title":"Plastic","text":"Plastic\nmaterial_response(m::Plastic, Δε::SymmetricTensor{2,3,T,6}, state::PlasticState{3}; kwargs...) where T","category":"page"},{"location":"materials/Plastic.html#MaterialModels.Plastic","page":"Plastic","title":"MaterialModels.Plastic","text":"Plastic(E, ν, σ_y, H, r, κ_∞, α_∞)\n\nPlasticity with von Mises yield surface and mixed non-linear kinematic + non-linear isotropic hardening. Both hardening laws are of saturation type.\n\nArguments\n\nE::Float64: Young's modulus\nν::Float64: Poisson's ratio\nσ_y: yield limit\nH: hardening modulus\nr: coupling parameter between isotropic and kinematic hardening\nκ_∞: saturation stress for isotropic hardening\nα_∞: saturation stress for kinematic hardening\n\n\n\n\n\n","category":"type"},{"location":"materials/Plastic.html#MaterialModels.material_response-Union{Tuple{T}, Tuple{Plastic,SymmetricTensor{2,3,T,6},PlasticState{3,T,M} where M where T}} where T","page":"Plastic","title":"MaterialModels.material_response","text":"material_response(m::Plastic, ε::SymmetricTensor{2,3,T,6}, state::PlasticState{3}; <keyword arguments>)\n\nReturn the stress tensor, stress tangent and the new MaterialState for the given strain ε and previous material state state.\n\nPlastic free energy:\n\nPsi^textp = frac12  r  H  k^2\n+ frac12left( 1-r right)  H  left sqrtfrac23 left textdev left(mathbfa right) right right^2\n\nVon Mises yield function:\n\nPhi = sqrtfrac32 left textdev left( boldsymbolsigma - boldsymbolalpha right) right - sigma_y - kappa\n\nAn associative flow rule and non-associative hardening rules are used. The evolution equations for the hardening variables are:\n\nbeginaligned\ndotk = -lambda left( 1 - frackappakappa_infty right) \ndotmathbfa = -lambda left( fracpartialPhipartialboldsymbolsigma \n+ frac32alpha_infty  textdev left( boldsymbolalpha right) right) \nendaligned\n\nKeyword arguments\n\ncache: Cache for the iterative solver, used by NLsolve.jl. It is strongly recommended to pre-allocate the cache for repeated calls to material_response. See get_cache.\noptions::Dict{Symbol, Any}: Solver options for the non-linear solver. Under the key :nlsolve_params keyword arguments for nlsolve can be handed over.\n\nSee NLsolve documentation. By default the Newton solver will be used.\n\n\n\n\n\n","category":"method"}]
}
